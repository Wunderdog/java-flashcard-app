type: edu
custom_name: stage7
files:
- name: test/common/DialogClue.kt
  visible: false
  text: |
    package common

    import org.hyperskill.hstest.testcase.CheckResult
    import org.hyperskill.hstest.testcase.TestCase


    // ---- DialogClue ----

    /** May be several lines or just one. */
    interface Phrase {
        fun toPhraseLines(): List<PhraseLine>
    }

    /** list of input and output lines, combined together. */
    fun compositePhrase(block: () -> List<Phrase>) = object : Phrase {
        override fun toPhraseLines() = block().flatMap { it.toPhraseLines() }
    }

    fun compositePhrase(vararg phrases: Phrase) = object : Phrase {
        override fun toPhraseLines() = phrases.flatMap { it.toPhraseLines() }
    }

    /** Either user (input) or output phrase. Each phrase should be a line. */
    sealed class PhraseLine : Phrase {
        override fun toPhraseLines() = listOf(this)
    }

    /** Some mutable data, that is passed across dialog phrases. */
    class Context {
        val rawData = mutableMapOf<String, Any>()
    }

    class UserLine(val text: String, val updateContext: CtxUpdate = {}) : PhraseLine() {

    }
    typealias CtxUpdate = (ctx: Context) -> Unit

    class OutputLine(val checker: (text: String, ctx: Context) -> CheckResult) : PhraseLine()

    /** This function creates a line with user input (our test input).
     *
     * Unfortunately we can't access the Context, when we adding user text.
     * This occurs because of HS test framework limitations:
     * we need to pass all inputs first, and then start checking outputs. */
    fun user(text: String, updateContext: (ctx: Context) -> Unit = {}) = UserLine(text, updateContext)

    fun anyLine(updateContext: CtxUpdate = {}) = OutputLine { _, ctx -> CheckResult.correct().also { updateContext(ctx) } }

    fun containing(
            vararg parts: String,
            ignoreCase: Boolean = true,
            hint: String? = null,
            updateContext: CtxUpdate = {}
    ) = OutputLine { line, context ->
        fun buildFeedback(): String {
            val feedback = StringBuilder()
            feedback.append("Your line\n`$line`\nshould contain ${parts.joinToString("`, `", "`", "`")}")
            if (ignoreCase) {
                feedback.append(" (ignoring case)")
            }
            feedback.append(".")
            if (hint != null) {
                feedback.append("\n$hint")
            }
            return feedback.toString()
        }

        var startIndex = 0
        for (part in parts) {
            startIndex = line.indexOf(part, startIndex, ignoreCase)
            if (startIndex == -1) {
                return@OutputLine CheckResult.wrong(buildFeedback())
            }
        }
        updateContext(context) // everything is correct, update context
        CheckResult.correct();
    }

    class DialogClue(private val phrases: List<PhraseLine>) {

        private val inputPhrases = phrases.filter { it is UserLine }.map { it as UserLine }
        private val outputPhrases = phrases.filter { it is OutputLine }.map { it as OutputLine }

        fun generateInput() = inputPhrases
                .joinToString("\n", postfix = "\n") { it.text }

        fun checkOutput(output: String): CheckResult {
            val lines = output.lines()
                    .filter { it.isNotBlank() }

            fun wrongOutputSizeFeedback() = CheckResult.wrong("The number of lines in your output is ${lines.size}, " +
                    "but it should be ${outputPhrases.size}. " +
                    "Check, that you output your lines with println, not print. And there are no extra outputs.")

    // here we store some mutable data from phrase to phrase
            val context = Context()

            val lineIter = lines.listIterator()
            phrases.forEach { phraseLine ->
                when (phraseLine) {
                    is UserLine -> phraseLine.updateContext(context)
                    is OutputLine -> {
                        if (!lineIter.hasNext()) {
                            return wrongOutputSizeFeedback()
                        }
                        val result = phraseLine.checker(lineIter.next(), context)
                        if (!result.isCorrect) {
                            return CheckResult.wrong(result.feedback)
                        }
                    }
                }
            }

            if (lineIter.hasNext()) {
                return wrongOutputSizeFeedback()
            }

            return CheckResult.correct();
        }
    }

    fun dialogTest(vararg phrases: Phrase, consoleArgs: Array<String> = emptyArray()): TestCase<DialogClue> {
        val dialogClue = DialogClue(phrases.flatMap { it.toPhraseLines() })
        return TestCase<DialogClue>()
                .setInput(dialogClue.generateInput())
                .setAttach(dialogClue)
                .addArguments(*consoleArgs)
    }
  learner_created: false
- name: test/common/FlashcardsStage7Test.kt
  visible: false
  text: |
    package common

    import org.hyperskill.hstest.stage.StageTest
    import org.hyperskill.hstest.testcase.CheckResult
    import org.hyperskill.hstest.testcase.TestCase
    import flashcards.Main
    import java.io.File


    abstract class FlashcardsStage7Test : StageTest<DialogClue>(Main::class.java) {

        override fun generate(): List<TestCase<DialogClue>> {
            File("capitals.txt").delete()
            File("capitalsNew.txt").delete()
            val tests = mutableListOf<TestCase<DialogClue>>()

            val capitalList = mutableListOf<Pair<String, String>>()
            fun capitals() = capitalList.toTypedArray()

            // wrappers for add/remove card, but saving cards to capitalList:
            fun addCapital(card: String, def: String) = addCard(card, def)
                    .also { capitalList += card to def }

            fun removeCapital(card: String) = removeCard(card)
                    .also { capitalList.removeIf { it.first == card } }

            // clear files
            tests += dialogTest(
                    exportCards("capitals.txt", 0),
                    exportCards("capitalsNew.txt", 0),
                    exit()
            )
            tests += dialogTest(
                    addCapital("France", "Paris"),
                    addCapital("Russia", "Moscow"),
                    askCards("France", "??", ""),
                    exit(),
                    exportArg(2),
                    consoleArgs = arrayOf("-export", "capitals.txt")
            )
            tests += dialogTest(
                    importArg(2, *capitals()),
                    addCapital("Japan", "Tokyo"),
                    askCards("Moscow", "Paris", "Tokyo"),
                    exit(),
                    exportArg(3),
                    consoleArgs = arrayOf("-import", "capitals.txt", "-export", "capitalsNew.txt")
            )
            tests += dialogTest(
                    importArg(3, *capitals()),
                    askCards("Moscow", "Paris", "Tokyo"),
                    removeCapital("Japan"),
                    exit(),
                    exportArg(2),
                    consoleArgs = arrayOf("-export", "capitals.txt", "-import", "capitalsNew.txt")
            )
            tests += dialogTest(
                    importArg(2, *capitals()),
                    exit(),
                    consoleArgs = arrayOf("-import", "capitals.txt")
            )

            return tests
        }

        override fun check(reply: String, clue: DialogClue): CheckResult {
            return clue.checkOutput(reply)
        }


        // ------ extensions for building a dialog: ------

        fun importArg(count: Int, vararg cards: Pair<String, String>) =
                containing("$count cards have been loaded",
                        updateContext = { ctx ->
                            cards.forEach { (card, def) ->
                                ctx.addCard(card, def)
                                ctx.wrongCards.removeAll(listOf(card))
                            }
                        })

        fun exportArg(count: Int) = containing("$count cards have been saved")


        fun inputAction(action: String) = compositePhrase {
            listOf(containing("action", hint = "This line should ask the action."), user(action))
        }

        inner class LogPhrase(val fileName: String) : Phrase {
            override fun toPhraseLines() = compositePhrase(
                    inputAction("log"),
                    anyLine(),
                    user(fileName),
                    OutputLine { text, ctx ->
                        val result = containing("saved", hint = "This line should indicate, that the log has been saved.").checker(text, ctx)
                        if (!result.isCorrect) {
                            return@OutputLine result
                        }
                        if (!File(fileName).exists()) {
                            return@OutputLine CheckResult.wrong("The log file $fileName does not exist.")
                        }
                        CheckResult.correct();
                    }
            ).toPhraseLines()
        }

        private fun log(fileName: String) = LogPhrase(fileName)

        private fun resetStats() = compositePhrase(
                inputAction("reset stats"), containing("reset", hint = "This line should confirm card statistics reset.",
                updateContext = { ctx -> ctx.wrongCards.clear() })
        )

        /** Between tests we cache wrong answered capitals to check hardest cards, when we restore them from file. */
        private val wrongAnweredCapitals: MutableList<String> = mutableListOf()

        /** [customWrongCards] are used to load saved wrong cards from the previous test. */
        fun hardestCards(customWrongCards: List<String>? = null) = compositePhrase(
                inputAction("hardest card"),
                OutputLine { text, ctx ->
                    if (customWrongCards != null) {
                        ctx.wrongCards.clear()
                        ctx.wrongCards.addAll(customWrongCards)
                    }
                    val groupedCards = ctx.wrongCards
                            .groupBy { it }.mapValues { (_, v) -> v.size }
                    val maxMistakes = groupedCards.values.max() ?: 0
                    val hardestCards = groupedCards.filterValues { it == maxMistakes }.keys.toList()

                    when (hardestCards.size) {
                        0 -> return@OutputLine containing("There are no cards with errors").checker(text, ctx)
                        1 -> return@OutputLine containing("The hardest card is \"${hardestCards[0]}\"",
                                "$maxMistakes").checker(text, ctx)
                        else -> {
                            hardestCards.forEach { card ->
                                if (card !in text) {
                                    return@OutputLine CheckResult.wrong("Your line `$text`\n" +
                                            "should contain the hardest cards " +
                                            "${hardestCards.joinToString("\", \"", "\"", "\"")} with $maxMistakes mistakes.")
                                }
                            }
                            val numberOfHardestCards = text.count { it == '"' }
                            if (numberOfHardestCards != hardestCards.size * 2) {
                                return@OutputLine CheckResult.wrong("Your line `$text`\n" +
                                        "contains more hardest cards, than expected. Expected: $hardestCards.")
                            }
                            if (maxMistakes.toString() !in text) {
                                if (numberOfHardestCards != hardestCards.size) {
                                    return@OutputLine CheckResult.wrong("Your line `$text`\n" +
                                            "should contain $maxMistakes mistakes for your hardest cards.")
                                }
                            }
                        }
                    }
                    CheckResult.correct();
                }
        )


        // extend dialog context with our own data:

        @Suppress("UNCHECKED_CAST")
        private val Context.cardToDef
            get() = rawData.getOrPut("cardToDef") { mutableMapOf<String, String>() } as MutableMap<String, String>

        @Suppress("UNCHECKED_CAST")
        /** All cards, that were answered wrong. */
        private val Context.wrongCards
            get() = rawData.getOrPut("wrongCards") { mutableListOf<String>() } as MutableList<String>


        @Suppress("UNCHECKED_CAST")
        private val Context.defToCard
            get() = rawData.getOrPut("defToCard") { mutableMapOf<String, String>() } as MutableMap<String, String>

        private fun Context.addCard(card: String, definition: String) {
            cardToDef[card] = definition
            defToCard[definition] = card
        }

        private fun Context.removeCard(card: String) {
            val def = cardToDef.remove(card)
            if (def != null) {
                defToCard.remove(def)
            }
        }


        private fun addCard(card: String, def: String) = compositePhrase(
                inputAction("add"),
                anyLine(), user(card),
                anyLine(), user(def),
                containing("has been added",
                        hint = "This line should add the pair (\"$card\":\"$def\").",
                        updateContext = { ctx -> ctx.addCard(card, def) })
        )


        private fun existingDef(card: String, def: String) = compositePhrase(
                inputAction("add"),
                anyLine(), user(card),
                anyLine(), user(def),
                containing("definition", "exists", hint = "This line should reject the existing definition `$def`.")
        )


        private fun existingCard(card: String) = compositePhrase(
                inputAction("add"),
                anyLine(), user(card),
                containing("card", "exists", hint = "This line should reject the existing card `$card`.")
        )

        private fun removeCard(card: String) = compositePhrase(
                inputAction("remove"),
                anyLine(), user(card),
                containing("has been removed", hint = "This line should remove the card `$card`.",
                        updateContext = { ctx -> ctx.removeCard(card) })
        )

        private fun removeNonExisting(card: String) = compositePhrase(
                inputAction("remove"),
                anyLine(), user(card),
                containing("Can't remove \"$card\"", hint = "This line should reject removing non existing card `$card`.")
        )


        private fun importCards(fileName: String, vararg cards: Pair<String, String>) = compositePhrase(
                inputAction("import"),
                anyLine(), user(fileName),
                containing("${cards.size} cards have been loaded",
                        updateContext = { ctx ->
                            val cardToDef = ctx.cardToDef
                            val defToCard = ctx.defToCard
                            cards.forEach { (card, def) ->
                                if (card in cardToDef) {
                                    defToCard.remove(cardToDef[card]) // erase wrong reverse link
                                }
                                ctx.addCard(card, def) // with update!!
                            }
                        })
        )

        private fun importNonExisting(fileName: String) = compositePhrase(
                inputAction("import"),
                anyLine(), user(fileName),
                containing("not found", hint = "This line should say, that the file $fileName does not exist.")
        )

        private fun exportCards(fileName: String, cardsSize: Int) = compositePhrase(
                inputAction("export"),
                anyLine(), user(fileName),
                containing("$cardsSize cards have been saved")
        )

        private fun exit() = compositePhrase(
                inputAction("exit"),
                anyLine()
        )

        /** Perform ask action. [ansDefs] are our test answers with definitions.
         * We don't know are they wrong or correct, because the test is random. */
        private fun askCards(vararg ansDefs: String, saveWrongAnsweredCapitals: Boolean = false) = compositePhrase {
            val startPhrases = listOf(
                    inputAction("ask"),
                    anyLine(), user(ansDefs.size.toString())
            )
            // here we add the dialog logic, by creating base OutputLine class with a custom checker
            // we use context to connect with neighbor checkers

            // iterate test answered definitions:
            val repeatingPhrases = ansDefs.map { ansDef ->
                compositePhrase(
                        OutputLine { text, ctx ->
                            val askedCard = text.dropWhile { it != '"' }.dropLastWhile { it != '"' }.trim('"')
                            if (askedCard.isEmpty()) {
                                return@OutputLine CheckResult.wrong("Not found card in quotes. " +
                                        "This line should ask the definition of a random card.")
                            }
                            if (askedCard !in ctx.cardToDef) {
                                return@OutputLine CheckResult.wrong("You asked the definition of the non existing card: `$askedCard`.")
                            }
                            ctx.rawData["lastAskedCard"] = askedCard
                            CheckResult.correct();
                        },
                        // unfortunately we can't access the Context in user action, see documentation of user()
                        user(ansDef),
                        // check the answer:
                        OutputLine { text, ctx ->
                            val askedCard = ctx.rawData["lastAskedCard"]?.toString()
                                    ?: throw IllegalStateException("Not found lastAskedCard in the `ask` checker.")
                            val cardToDef = ctx.cardToDef
                            val defToCard = ctx.defToCard
                            val rightAns = cardToDef[askedCard]

                            val hint = "The asked card was `$askedCard`, the answer was `$ansDef`."
                            if (cardToDef[askedCard] == ansDef)
                                containing("Correct answer", hint = hint).checker(text, ctx)
                            else {
                                ctx.wrongCards += askedCard

                                val isDefFor = defToCard[ansDef]
                                if (isDefFor != null) {
                                    containing("Wrong answer", "The correct one is \"$rightAns\"",
                                            "you've just written the definition of \"$isDefFor\"", hint = hint).checker(text, ctx)
                                } else {
                                    // should not contain definition hint!!
                                    if (text.contains("you've just written the definition of")) {
                                        CheckResult.wrong("Your line\n`$text`\nshould NOT contain " +
                                                "`you've just written the definition of`.\n$hint")
                                    } else {
                                        containing("Wrong answer", "The correct one is \"$rightAns\"", hint = hint).checker(text, ctx)
                                    }

                                }
                            }.also {
                                // only for these tests. To test restoring wrong capitals from file.
                                if (saveWrongAnsweredCapitals) {
                                    wrongAnweredCapitals.clear()
                                    wrongAnweredCapitals.addAll(ctx.wrongCards)
                                }
                            }
                        }
                )
            }
            (startPhrases + repeatingPhrases)
        }
    }
  learner_created: false
- name: test/FlashcardsTest.java
  visible: false
  text: |
    import common.FlashcardsStage7Test;

    public class FlashcardsTest extends FlashcardsStage7Test {
        // just empty class, but not abstract so it can be run
    }
  learner_created: false
- name: src/flashcards/Main.java
  visible: true
  text: |
    package flashcards;
    import java.util.Scanner;

    public class Main {
        public static void main(String[] args) {
            Scanner scan = new Scanner(System.in);
            System.out.println("Input the number of cards:");
            int num_cards = Integer.parseInt(scan.nextLine());
            Card[] cards = new Card[num_cards];
            {
                String card;
                String def;

                for (int i = 0; i < num_cards; i++) {
                    System.out.println(String.format("The card #%d:", i + 1));
                    card = scan.nextLine();

                    System.out.println(String.format("The definition of the card #%d:", i + 1));
                    def = scan.nextLine();
                    cards[i] = new Card(card, def);
                }
            }

            String output = "Card:\n"
                    + "%s\n"
                    + "Definition:\n"
                    + "%s";
            String ans;
            for (Card card : cards) {
                System.out.println(String.format("Print the definition of \"%s\":", card.getCard()));
                ans = scan.nextLine();
                if (card.getDef().equals(ans)) {
                    System.out.println("Correct answer.");
                } else {
                    System.out.println(String.format("Wrong answer. The correct one is \"%s\"", card.getDef()));
                }

                //        System.out.println(String.format(output, card, def));

            }

        }
    }
  learner_created: false
- name: src/flashcards/Card.java
  visible: true
  text: |
    package flashcards;

    public class Card {
        private
            String card;
            String def;

        Card() {

        }
        Card(String card, String def) {
            this.card = card;
            this.def = def;
        }

        public String getCard() {
            return card;
        }
        public void setCard(String card) {
            this.card = card;
        }
        public String getDef() {
            return def;
        }
        public void setDef(String def) {
            this.def = def;
        }

    }
  learner_created: false
- name: src/flashcards/TeePrintStream.java
  visible: true
  text: |
    package flashcards;

    import java.io.*;

    public class TeePrintStream extends PrintStream {
        private final PrintStream second;
        private final InputStream input;
        private final InputStreamReader inReader;

        public TeePrintStream(OutputStream out, PrintStream second, InputStream input) {
            super(out);
            this.second = second;
            this.input = input;
            this.inReader = new InputStreamReader(input);
        }
        public InputStream getIn() {
            return input;
        }
        /*
        * Closes the main stream.
        * The second stream is just flushed but <b>not</b> closed.
        * @see java.io.PrintStream#close()
        * */
        @Override
        public void close() {
            super.close();
        }

        @Override
        public void flush() {
            super.flush();
            second.flush();
        }
        @Override
        public void write(byte[] buf, int off, int len) {
            super.write(buf, off, len);
            second.write(buf, off, len);
            while (true) {
                try {
                    if (!inReader.ready()) break;
                    System.out.println("READY 1");
                    super.write(inReader.read());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        @Override
        public void write(int b) {
            super.write(b);
            second.write(b);
            while (true) {
                try {
                    if (!inReader.ready()) break;
                    System.out.println("READY 2");

                    super.write(inReader.read());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        @Override
        public void write(byte[] b) throws IOException {
            super.write(b);
            second.write(b);
            while (true) {
                try {
                    if (!inReader.ready()) break;
                    System.out.println("READY 3");
                    super.write(inReader.read());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
  learner_created: true
- name: src/flashcards/CustomInputFilter.java
  visible: true
  text: |
    package flashcards;

    import java.io.*;

    public class CustomInputFilter extends FilterInputStream {
        private InputStream in;
        private PrintStream out;

        CustomInputFilter(InputStream in, PrintStream out) {
            super(in);
            this.out = out;
        }
        @Override
        public int read() throws IOException {
            int chr = super.read();
            out.write(chr);
            System.out.println((char)chr);
            return chr;
        }
        @Override
        public int read(byte[] b, int off, int len) throws IOException {
            int bytesRead = super.read(b, off, len);
            out.write(b, off, bytesRead);
            return bytesRead;
        }
    }
  learner_created: true
- name: capitals.txt
  visible: true
  text: |
    "France","Paris",4
    "Russia","Moscow",6
  learner_created: true
- name: src/flashcards/ReusableBufferedInputStream.java
  visible: true
  text: |-
    package flashcards;

    import java.io.IOException;
    import java.io.InputStream;

    public class ReusableBufferedInputStream extends InputStream {
        private byte[]      buffer = null;
        private int         writeIndex = 0;
        private int         readIndex  = 0;
        private InputStream source = null;

        public ReusableBufferedInputStream(byte[] buffer) {
            this.buffer = buffer;
        }
        public ReusableBufferedInputStream setSource(InputStream source){
            this.source = source;
            this.writeIndex = 0;
            this.readIndex  = 0;
            return this;
        }
        @Override
        public int read() throws IOException {

            if(readIndex == writeIndex) {
                if(writeIndex == buffer.length) {
                    writeIndex = 0;
                    readIndex  = 0;
                }
                //data should be read into buffer.
                int bytesRead = readBytesIntoBuffer();
                while(bytesRead == 0) {
                    //continue until you actually get some bytes !
                    bytesRead = readBytesIntoBuffer();
                }
                //if no more data could be read in, return -1;
                if(bytesRead == -1) {
                    return -1;
                }
            }
            return 255 & this.buffer[readIndex++];
        }
        private int readBytesIntoBuffer() throws IOException {
            int bytesRead = this.source.read(this.buffer, this.writeIndex, this.buffer.length - this.writeIndex);
            writeIndex += bytesRead;
            return bytesRead;
        }
        @Override
        public void close() throws IOException {
            this.source.close();
        }
    }
  learner_created: true
- name: capitalsNew.txt
  visible: true
  text: |
    "France","Paris"
  learner_created: true
- name: src/flashcards/CardParser.java
  visible: true
  text: |
    package flashcards;

    import java.util.regex.Pattern;
    import java.util.regex.Matcher;

    public class CardParser {

        public static String escapeCsv(String input) {
            return input.replaceAll(",", "\\,")
                    .replaceAll(" +", " ")
                    .replaceAll("\"", "\\\"");
        }
        public static String unescapeCsv(String output) {
            return output.trim().replaceAll("^( *\")|(\" *)$", "")
                    .replaceAll("\\\\,",",")
                    .replaceAll("\\\\\"", "\"").trim();
        }
        public static Card parseCard(String line, CardBank cards) {
            String matchStr = "((?<=((?<!\\\\)\")) *, *)";
            String matchStr2 = "((?<!(\")) *, *)";
            String matchStr3 = "(?:(?<!\\\\),)\\s*(?:\")?(\\d+)(?:\")?$";
            String desc = "";
            String def = "";
            int misses = 0;

            Matcher match3 = Pattern.compile(matchStr3).matcher(line);

            if (line.isEmpty()) {return null;}
            if (match3.find()) {
                try {
                    misses = Integer.parseInt(match3.group(1));
                } catch(NumberFormatException nfe) {
                    System.out.println("Error reading number of misses.");
                }
                line = line.substring(0, match3.start());
            }
            Matcher match = Pattern.compile(matchStr).matcher(line);
            Matcher match2 = Pattern.compile(matchStr2).matcher(line);
            if (match.find()) {
                desc = unescapeCsv(line.substring(0, match.start()));
                def = unescapeCsv(line.substring(match.end()));
            } else if (match2.find()) {
                desc = unescapeCsv(line.substring(0, match2.start()));
                def = unescapeCsv(line.substring(match2.end()));
            } else {
                return null;
            }
            cards.appendToMisses(desc, misses);
            return new Card(desc, def);
        }
    }
  learner_created: true
- name: src/flashcards/DoubleBufferInputStream.java
  visible: true
  text: |
    package flashcards;

    import java.io.IOException;
    import java.io.InputStream;

    public class DoubleBufferInputStream extends InputStream {
        private byte[]      buffer = null;
        private byte[]      buffer2 = null;
        private int         writeIndex = 0;
        private int         readIndex  = 0;
        private InputStream source = null;

        public DoubleBufferInputStream(byte[] buffer) {
            System.out.println("NEW DOUBLE BUFFER INPUT STREAM");
            this.buffer = buffer;
            this.buffer2 = buffer.clone();
        }
        public DoubleBufferInputStream setSource(InputStream source){
            this.source = source;
            this.writeIndex = 0;
            this.readIndex  = 0;
            return this;
        }
        @Override
        public int read() throws IOException {
            if(readIndex == writeIndex) {
                if(writeIndex == buffer.length) {
                    writeIndex = 0;
                    readIndex  = 0;
                }
                //data should be read into buffer.
                int bytesRead = readBytesIntoBuffer();
                while(bytesRead == 0) {
                    //continue until you actually get some bytes !
                    bytesRead = readBytesIntoBuffer();
                }
                System.out.println("Bytes Read: " + bytesRead);
                //if no more data could be read in, return -1;
                if(bytesRead == -1) {
                    return -1;
                }
            }
            return 255 & this.buffer[readIndex++];
        }
        private int readBytesIntoBuffer() throws IOException {
            int bytesRead = this.source.read(this.buffer, this.writeIndex, this.buffer.length - this.writeIndex);
            writeIndex += bytesRead;
            return bytesRead;
        }
        @Override
        public void close() throws IOException {
            System.out.println("CLOSE");
            this.source.close();
        }
    }
  learner_created: true
- name: src/flashcards/CardBank.java
  visible: true
  text: |
    package flashcards;

    import java.util.*;

    public class CardBank implements Iterable<Card> {
        private ArrayList<Card> cards = new ArrayList<>();
        private Map<String, String> descs = new HashMap<>();
        private Map<String, String> defs = new HashMap<>();
        private Map<String, Integer> misses = new HashMap<>();
        private ArrayList<String> questions = new ArrayList<>();
        private Random rand = new Random(new Date().getTime());
        private int mostMisses = 0;

        CardBank() {}
        CardBank(Card[] cards) {
            addAll(cards);
        }
        private int addAll(Card[] cards) {
            int cardsAdded = 0;
            for (Card card : cards) {
                cardsAdded += addCard(card);
            }
            return cardsAdded;
        }
        public boolean containsDesc(String desc) {
            return descs.containsKey(desc);
        }
        public boolean containsDef(String def) {
            return defs.containsKey(def);
        }
        public String getByDef(String def) {
            return defs.get(def);
        }
        public String getByDesc(String desc) {
            return descs.get(desc);
        }
        public int addCard(Card newCard) {
            String desc = newCard.getCard();
            String def = newCard.getDef();
            if (containsDesc(desc) && !containsDef(def)) {
                removeCard(desc);
            }
            if (!containsDesc(desc) && !containsDef(def)) {
                descs.put(desc, def);
                defs.put(def, desc);
                cards.add(newCard);
                questions.add(desc);
                return 1;
            }
            return 0;
        }
        public int removeCard(String desc) {
            if (containsDesc(desc)) {
                for (Card card : cards) {
                    if(card.getDesc().equals(desc)) {
                        cards.remove(card);
                        break;
                    }
                }
                defs.remove(descs.get(desc));
                descs.remove(desc);
                questions.remove(desc);
                misses.remove(desc);
                return 1;
            }
            return 0;
        }
        public Card getRandom() {
            if (questions.size() == 0) {
                questions.addAll(descs.keySet());
            }
            int index = rand.nextInt(questions.size());
            String desc = questions.get(index);
            Card result = new Card(desc, descs.get(desc));
            questions.remove(index);
            return result;
        }
        public int appendToMisses(String key, int value) {
            misses.merge(key, value, (a, b) -> a + b);
            mostMisses = misses.get(key) > mostMisses ? misses.get(key) : mostMisses;
            return misses.get(key);
        }
        public int addMiss(String key) {
            return appendToMisses(key, 1);
        }
        public int getMisses(String key) {
            return misses.get(key) == null ? 0 : misses.get(key);
        }
        public int setMisses(String key, int value) {
            misses.put(key, value);
            mostMisses = misses.get(key) > mostMisses ? misses.get(key) : mostMisses;
            return misses.get(key);
        }
        public String[] getMostMissed() {
            return misses.keySet().stream().filter((val) -> misses.get(val) == mostMisses).toArray(String[]::new);
        }
        public int getMaxMisses() {
            return mostMisses;
        }
        public void resetStats() {
            misses.clear();
            mostMisses = 0;
        }
        @Override
        public Iterator<Card> iterator() {
            return cards.iterator();
        }
    }
  learner_created: true
- name: src/flashcards/Menu.java
  visible: true
  text: |
    package flashcards;

    import java.io.*;
    import java.nio.charset.StandardCharsets;
    import java.util.Arrays;
    import java.util.Scanner;
    import java.util.stream.Collectors;
    import static flashcards.CardParser.*;

    public class Menu {
        final String utf8 = StandardCharsets.UTF_8.name();
        CardBank cards = new CardBank();
        Scanner scan;

        public Menu(Scanner scan) {
            this.scan = scan;
        }
        public void add(int num_cards) {
            String card = "";
            String def = "";
            boolean exists;
            for (int i = 0; i < num_cards; i++) {
                exists = false;
                System.out.println(String.format("The card"));

                card = scan.nextLine().trim().replaceAll("[ +|\n]", " ");
                if (cards.containsDesc(card)) {
                    exists = true;
                    System.out.println(String.format("The card \"%s\" already exists.", card));
                }
                if (exists == false) {
                    System.out.println(String.format("The definition of the card:"));
                    def = scan.nextLine().trim().replaceAll("[ +|\n]", " ");
                    if (cards.containsDef(def)) {
                        exists = true;
                        System.out.println(String.format("The definition \"%s\" already exists.", def));
                    }
                }
                if (exists == false) {
                    cards.addCard(new Card(card, def));
                    System.out.println(String.format("The pair (\"%s\":\"%s\") has been added.\n", card, def));
                }
            }
        }
        public void add() {add(1);}
        public void remove() {
            System.out.println("The card:");
            remove(scan.nextLine().trim().replaceAll("[ +|\n]", " "));
        }
        public void remove(String desc) {
            if (cards.containsDesc(desc)) {
                cards.removeCard(desc);
                System.out.println("The card has been removed.\n");
            } else {
                System.out.println(String.format("Can't remove \"%s\": there is no such card.\n", desc));
            }
        }
        public void ask() {
            boolean valid = false;
            int numQuestions = 0;
            do {
            try {
                System.out.println("How many times to ask?");
                numQuestions = Integer.parseInt(scan.nextLine().trim());
                valid = true;
            } catch (NumberFormatException nme) {
                System.out.println("Invalid number. Try again:\n");
            }
            } while(valid == false);
            ask(numQuestions);
        }
        public void ask(int numQuestions) {
            if (numQuestions <= 0) {
                return;
            }
            String ans;
            String end;
            Card card;
            for (int i = 0; i < numQuestions; i++) {
                card = cards.getRandom();
                System.out.println(String.format("Print the definition of \"%s\":", card.getCard()));
                ans = scan.nextLine().trim().replaceAll("[ +|\n]", " ");
                if (card.getDef().toLowerCase().equals(ans.toLowerCase())) {
                    System.out.println("Correct answer.\n");
                } else {
                    cards.addMiss(card.getDesc());
                    end = cards.containsDef(ans) ?
                            String.format(", you\'ve just written the definition of \"%s\".", cards.getByDef(ans))
                            : ".";
                    System.out.println(String.format("Wrong answer. The correct one is \"%s\"%s\n", card.getDef(), end));
                }
            }

        }
        public void exportCards() {
            System.out.println("File name:");
            exportCards(scan.nextLine());
        }
        public void exportCards(String fileName) {
            try (PrintWriter writer = new PrintWriter(fileName)) {
                int numSaved = 0;
                for (Card card : cards) {
                    writer.printf("\"%s\",\"%s\",%d\n",
                            escapeCsv(card.getDesc()),
                            escapeCsv(card.getDef()),
                            cards.getMisses(card.getDesc()));
                    numSaved++;
                }
                System.out.println(String.format("%d cards have been saved.\n", numSaved));
            } catch (IOException ioe) {
                System.out.println("Error: Unable to  write to file.\n");
            }
        }
        public void importCards() {
            System.out.println("File name:");
            importCards(scan.nextLine());
        }
        public void importCards(String fileName) {

            try (Scanner reader = new Scanner(new File(fileName))) {
                int numAdded = 0;
                Card importedCard;
                String next;
                while (reader.hasNext()) {
                    next = reader.nextLine();
                    importedCard = parseCard(next, cards);
                    if (importedCard != null) {
                        cards.addCard(importedCard);
                        numAdded += 1;
                    }
                }
                System.out.println(String.format("%d cards have been loaded.\n", numAdded));
            } catch (FileNotFoundException ioe) {
                System.out.println("File not found.\n");
            }
        }
        public void log(ByteArrayOutputStream baos) {
            System.out.println("File name:");
            String fileName = scan.nextLine();
            String output = "";
            try (PrintWriter writer = new PrintWriter(fileName)) {
                output = baos.toString(utf8);
                int numSaved = 0;
                writer.printf(output);
                System.out.println(String.format("The log has been saved.\n"));
            } catch (UnsupportedEncodingException e) {
                e.printStackTrace();
            } catch (IOException ioe) {
                System.out.println("Error: Unable to  write to file.\n");
            }
        }
        public void printStats() {
            String[] mostMissed = cards.getMostMissed();
            if (mostMissed.length == 0) {
                System.out.println("There are no cards with errors.\n");
            } else {
                String miss_string = Arrays.asList(mostMissed).stream().collect(Collectors.joining("\", \"", "\"", "\""));
                String out = String.format("The hardest card%s %s. You have %d errors answering %s.\n",
                        mostMissed.length > 1 ? "s are" : " is",
                        miss_string, cards.getMaxMisses(),
                        mostMissed.length > 1 ? "them": "it");
                System.out.println(out);
            }
        }
        public void resetStats() {
            cards.resetStats();
            System.out.println("Card statistics have been reset.\n");
        }
    }
  learner_created: true
- name: testLog.txt
  visible: true
  text: |
    Input the action (add, remove, import, export, ask, exit, log, hardest card, reset stats):
    hardest card
    There are no cards with errors.

    Input the action (add, remove, import, export, ask, exit, log, hardest card, reset stats):
    add
    The card
    France
    The definition of the card:
    Paris
    The pair ("France":"Paris") has been added.

    Input the action (add, remove, import, export, ask, exit, log, hardest card, reset stats):
    ask
    How many times to ask?
    2
    Print the definition of "France":
    France
    Wrong answer. The correct one is "Paris".

    Print the definition of "France":
    ??
    Wrong answer. The correct one is "Paris".

    Input the action (add, remove, import, export, ask, exit, log, hardest card, reset stats):
    hardest card
    The hardest card is "France". You have 2 errors answering it.

    Input the action (add, remove, import, export, ask, exit, log, hardest card, reset stats):
    reset stats
    Card statistics have been reset.

    Input the action (add, remove, import, export, ask, exit, log, hardest card, reset stats):
    hardest card
    There are no cards with errors.

    Input the action (add, remove, import, export, ask, exit, log, hardest card, reset stats):
    add
    The card
    Russia
    The definition of the card:
    Moscow
    The pair ("Russia":"Moscow") has been added.

    Input the action (add, remove, import, export, ask, exit, log, hardest card, reset stats):
    ask
    How many times to ask?
    2
    Print the definition of "Russia":
    ??
    Wrong answer. The correct one is "Moscow".

    Print the definition of "France":
    ??
    Wrong answer. The correct one is "Paris".

    Input the action (add, remove, import, export, ask, exit, log, hardest card, reset stats):
    hardest card
    The hardest cards are "France", "Russia". You have 1 errors answering them.

    Input the action (add, remove, import, export, ask, exit, log, hardest card, reset stats):
    ask
    How many times to ask?
    2
    Print the definition of "Russia":
    ??
    Wrong answer. The correct one is "Moscow".

    Print the definition of "Russia":
    ??
    Wrong answer. The correct one is "Moscow".

    Input the action (add, remove, import, export, ask, exit, log, hardest card, reset stats):
    hardest card
    The hardest card is "Russia". You have 3 errors answering it.

    Input the action (add, remove, import, export, ask, exit, log, hardest card, reset stats):
    ask
    How many times to ask?
    2
    Print the definition of "France":
    ??
    Wrong answer. The correct one is "Paris".

    Print the definition of "France":
    ??
    Wrong answer. The correct one is "Paris".

    Input the action (add, remove, import, export, ask, exit, log, hardest card, reset stats):
    hardest card
    The hardest cards are "France", "Russia". You have 3 errors answering them.

    Input the action (add, remove, import, export, ask, exit, log, hardest card, reset stats):
    ask
    How many times to ask?
    2
    Print the definition of "Russia":
    ??
    Wrong answer. The correct one is "Moscow".

    Print the definition of "France":
    ??
    Wrong answer. The correct one is "Paris".

    Input the action (add, remove, import, export, ask, exit, log, hardest card, reset stats):
    hardest card
    The hardest cards are "France", "Russia". You have 4 errors answering them.

    Input the action (add, remove, import, export, ask, exit, log, hardest card, reset stats):
    ask
    How many times to ask?
    2
    Print the definition of "Russia":
    ??
    Wrong answer. The correct one is "Moscow".

    Print the definition of "Russia":
    ??
    Wrong answer. The correct one is "Moscow".

    Input the action (add, remove, import, export, ask, exit, log, hardest card, reset stats):
    hardest card
    The hardest card is "Russia". You have 6 errors answering it.

    Input the action (add, remove, import, export, ask, exit, log, hardest card, reset stats):
    export
    File name:
    capitals.txt
    2 cards have been saved.

    Input the action (add, remove, import, export, ask, exit, log, hardest card, reset stats):
    log
    File name:
    testLog.txt
  learner_created: false
feedback_link: https://hyperskill.org/projects/44/stages/238/implement
status: Solved
record: 7
